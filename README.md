# راهنمای جامع سیستم‌های پیام‌رسان (Redis, RabbitMQ, Kafka) برای توسعه‌دهندگان جنگو
در معماری‌های مدرن و مقیاس‌پذیر، سرویس‌ها باید به صورت غیرهمزمان (Asynchronous) با یکدیگر ارتباط برقرار کنند تا از کندی و از کار افتادن کل سیستم جلوگیری شود. ابزارهایی مانند Redis، RabbitMQ و Kafka که به عنوان Message Broker یا Message Queue شناخته می‌شوند، این ارتباط غیرهمزمان را مدیریت می‌کنند. یک مهندس نرم افزار باید بداند چه زمانی و چرا از هرکدام استفاده کند.

## (Redis) 🌶️
<div dir="rtl">
Redis یک سیستم ذخیره‌سازی داده به‌صورت کلید-مقدار (Key-Value) است که به دلیل سرعت بالا و سادگی، به‌عنوان پایگاه داده، کش یا پیام‌رسان استفاده می‌شود.
</div>

### معماری کلی Redis

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Client App    │    │   Redis Server  │    │   Persistence   │
│                 │◄──►│                 │◄──►│                 │
│  Django Views   │    │  - Data Types   │    │  - RDB Snapshot │
│  - Celery       │    │  - Pub/Sub      │    │  - AOF Log      │
│  - Cache        │    │  - Streams      │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```
### ساختار داخلی و مکانیزم
Redis داده‌ها را در حافظه اصلی (RAM) نگه می‌دارد که باعث دسترسی سریع می‌شود. از انواع داده‌هایی مثل لیست، مجموعه و هش پشتیبانی می‌کند.
### پروتکل‌ها
از پروتکل RESP (REdis Serialization Protocol) استفاده می‌کند که متنی و ساده است.
### مدیریت پیام‌ها (Enqueue و Dequeue)
با استفاده از لیست‌ها، پیام‌ها با دستور LPUSH به صف اضافه و با RPOP حذف می‌شوند.
### مدل تحویل پیام
 مدل ساده FIFO (اولین ورودی، اولین خروجی) را دنبال می‌کند.
### تولید و مصرف پیام‌ها
تولیدکنندگان پیام را به لیست اضافه و مصرف‌کنندگان آن را می‌خوانند.
### ترتیب پیام‌ها
ترتیب پیام‌ها بر اساس ترتیب ورود حفظ می‌شود.
### بهترین موارد استفاده
کش کردن داده‌ها (مثل نتایج کوئری‌ها)، مدیریت جلسه‌های کاربران، و پیام‌رسانی ساده در پروژه‌های Django.
### پیکربندی برای دسترسی بالا و پایداری
برای پروژه‌های مقیاس‌پذیر، از Redis Sentinel (برای Failover) یا Redis Cluster (برای توزیع داده) استفاده کنید. برای پایداری، AOF (ثبت تراکنش‌ها) و RDB (تهیه نسخه پشتیبان) را فعال کنید.
### استفاده در Django
 با کتابخانه django-redis برای کش کردن و مدیریت جلسه‌ها ادغام می‌شود.
### نرم‌افزارهای مکمل
ابزارهایی مثل RedisInsight برای مانیتورینگ و مدیریت
### کارایی، نقاط قوت و ضعف
- **قوت**: سرعت بالا، سادگی، پشتیبانی از داده‌های متنوع.
- **ضعف**: محدودیت حجم داده (به دلیل RAM)، عدم پشتیبانی از پیام‌رسانی پیچیده.

## (RabbitMQ) 🐇


### معماری کلی RabbitMQ

```
┌──────────────┐    ┌─────────────────────────────────────┐    ┌──────────────┐
│   Producer   │    │            RabbitMQ Broker          │    │   Consumer   │
│              │    │                                     │    │              │
│ Django Views │───►│ Exchange ──► Queue ──► Consumer     │───►│ Celery Worker│
│ API Endpoints│    │    │                                │    │ Background   │
│              │    │    └──► Dead Letter Queue           │    │ Services     │
└──────────────┘    └─────────────────────────────────────┘    └──────────────┘
```

### ساختار داخلی و مکانیزم
پیام‌ها در صف‌ها (Queues) ذخیره و با استفاده از تبادل‌ها (Exchanges) مسیریابی می‌شوند.
### پروتکل‌ها
AMQP، MQTT، STOMP و HTTP را پشتیبانی می‌کند
### مدیریت پیام‌ها (Enqueue و Dequeue)
تولیدکنندگان پیام را به تبادل‌ها ارسال می‌کنند، سپس پیام‌ها بر اساس قوانین به صف‌ها می‌روند و مصرف‌کنندگان آن‌ها را برمی‌دارند.
### مدل تحویل پیام
مدل‌های Direct (مستقیم)، Fanout (پخش)، Topic (موضوعی) و Headers را ارائه می‌دهد.
### تولید و مصرف پیام‌ها
تولیدکنندگان پیام را به تبادل و مصرف‌کنندگان از صف دریافت می‌کنند.
### ترتیب پیام‌ها
در هر صف ترتیب حفظ می‌شود، اما در مدل‌های خاص ممکن است تغییر کند.
### بهترین موارد استفاده
پردازش وظایف پس‌زمینه (مثل ارسال ایمیل)، توزیع بار و ارتباط بین میکروسرویس‌ها در Django.
### پیکربندی برای دسترسی بالا و پایداری
از Clustering و Mirrored Queues برای دسترسی بالا و Publisher Confirms و Consumer Acknowledgements برای پایداری استفاده کنید.
### استفاده در Django
با Celery برای مدیریت وظایف پس‌زمینه ادغام می‌شود.
### نرم‌افزارهای مکمل
RabbitMQ Management Plugin یا Prometheus برای مانیتورینگ.
### کارایی، نقاط قوت و ضعف
- **قوت**: انعطاف‌پذیری، پشتیبانی از مدل‌های متنوع پیام‌رسانی.
- **ضعف**: پیچیدگی در مدیریت، مصرف منابع بیشتر.

## (Apache Kafka) 🌊

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Kafka Cluster                                     │
│                                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                      │
│  │   Broker 1  │    │   Broker 2  │    │   Broker 3  │                      │
│  │             │    │             │    │             │                      │
│  │ Topic: user │    │ Topic: user │    │ Topic: user │                      │
│  │ Part-0 (L)  │    │ Part-1 (L)  │    │ Part-2 (L)  │    L = Leader        │
│  │ Part-1 (F)  │    │ Part-2 (F)  │    │ Part-0 (F)  │    F = Follower      │
│  └─────────────┘    └─────────────┘    └─────────────┘                      │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        Zookeeper                                    │    │
│  │              (Metadata & Coordination)                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```
ساختار داخلی و مکانیزم:
    داده‌ها در موضوعات (Topics) ذخیره و هر موضوع به پارتیشن‌هایی (Partitions) تقسیم می‌شود که روی سرورهای مختلف توزیع می‌شوند.
    پروتکل‌ها:
    از پروتکل اختصاصی مبتنی بر TCP استفاده می‌کند.
    مدیریت پیام‌ها (Enqueue و Dequeue):
    تولیدکنندگان پیام را به موضوعات می‌فرستند و مصرف‌کنندگان با استفاده از آفست (Offset) پیام‌ها را می‌خوانند.
    مدل تحویل پیام:
    تحویل بر اساس آفست است و مصرف‌کنندگان می‌توانند پیام‌ها را ترتیبی یا از نقطه خاص بخوانند.
    تولید و مصرف پیام‌ها:
    تولیدکنندگان به موضوعات ارسال و مصرف‌کنندگان (به‌صورت گروهی یا تکی) دریافت می‌کنند.
    ترتیب پیام‌ها:
    در هر پارتیشن ترتیب حفظ می‌شود، اما در کل موضوع تضمین نمی‌شود.

مفاهیم حرفه‌ای

    بهترین موارد استفاده:
    استریم داده‌ها (مثل تحلیل زنده)، لاگ‌گیری و پردازش داده‌های بزرگ در Django.
    پیکربندی برای دسترسی بالا و پایداری:
    از Replication و تنظیمات Acks و Min Insync Replicas برای پایداری و Clustering برای دسترسی بالا استفاده کنید.
    استفاده در Django:
    با کتابخانه‌هایی مثل confluent-kafka برای استریم داده ادغام می‌شود.
    نرم‌افزارهای مکمل:
    Kafka Manager یا Confluent Control Center برای مدیریت.
    کارایی، نقاط قوت و ضعف:
        قوت: مقیاس‌پذیری بالا، مناسب داده‌های بزرگ.
        ضعف: پیچیدگی، نیاز به سخت‌افزار قوی.

